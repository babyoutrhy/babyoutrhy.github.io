<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced LuaU Obfuscator ¬∑ Full Identifier Renaming</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            background: linear-gradient(145deg, #0c0b14 0%, #1a1825 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
            padding: 1rem;
            margin: 0;
        }
        .card {
            background: rgba(22, 20, 30, 0.9);
            backdrop-filter: blur(8px);
            border: 1px solid #3f3b5c;
            border-radius: 32px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.8), 0 0 0 1px #2f2b44 inset;
            padding: 2.5rem 2rem;
            width: min(500px, 100%);
            transition: 0.2s;
        }
        h1 {
            color: #eae6ff;
            font-weight: 600;
            font-size: 2.2rem;
            letter-spacing: -0.5px;
            margin-bottom: 0.4rem;
            text-shadow: 0 2px 5px #00000060;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        h1 span {
            background: #6d5f9c;
            font-size: 1rem;
            padding: 0.2rem 0.8rem;
            border-radius: 60px;
            font-weight: 400;
            letter-spacing: 0.3px;
            color: #fff;
            text-transform: uppercase;
            margin-left: 8px;
        }
        .sub {
            color: #9f96c5;
            margin-bottom: 2rem;
            font-size: 0.95rem;
            border-left: 4px solid #6d5f9c;
            padding-left: 1rem;
        }
        .file-area {
            background: #13111c;
            border: 2px dashed #3b344e;
            border-radius: 24px;
            padding: 1.8rem 1rem;
            text-align: center;
            transition: border 0.2s, background 0.2s;
            cursor: pointer;
            margin-bottom: 2rem;
        }
        .file-area:hover {
            border-color: #8b7acb;
            background: #1b1728;
        }
        .file-area label {
            display: block;
            cursor: pointer;
        }
        .file-area svg {
            width: 42px;
            height: 42px;
            stroke: #a796e0;
            stroke-width: 1.5;
            fill: none;
            margin-bottom: 12px;
        }
        .file-area .browse-text {
            color: #cbc3f0;
            font-weight: 500;
            font-size: 1.2rem;
        }
        .file-area .file-hint {
            color: #6c6190;
            font-size: 0.85rem;
            margin-top: 8px;
        }
        #fileInput {
            display: none;
        }
        #fileName {
            background: #1f1b30;
            border-radius: 40px;
            padding: 0.6rem 1.2rem;
            color: #ddd2ff;
            font-size: 0.9rem;
            border: 1px solid #3c3452;
            margin-bottom: 1.8rem;
            word-break: break-all;
            text-align: center;
        }
        .action-btn {
            background: #6d5f9c;
            border: none;
            border-radius: 60px;
            padding: 1rem 2rem;
            width: 100%;
            font-weight: 600;
            font-size: 1.4rem;
            color: white;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: 0.15s;
            box-shadow: 0 8px 0 #3d315b, 0 10px 20px #00000055;
            border: 1px solid #9a88da;
            margin-bottom: 1.2rem;
        }
        .action-btn:active {
            transform: translateY(6px);
            box-shadow: 0 2px 0 #3d315b, 0 5px 12px #00000055;
        }
        .action-btn:disabled {
            opacity: 0.5;
            transform: translateY(4px);
            box-shadow: 0 4px 0 #3d315b;
            pointer-events: none;
        }
        #status {
            background: #1b1728;
            border-radius: 40px;
            padding: 0.8rem 1.2rem;
            color: #b7abdf;
            font-size: 0.95rem;
            border: 1px solid #423d5a;
            text-align: center;
            transition: 0.2s;
        }
        footer {
            margin-top: 1.8rem;
            color: #4b4465;
            font-size: 0.75rem;
            text-align: center;
        }
    </style>
    <!-- Load luaparse from CDN for full Lua parsing -->
    <script src="https://unpkg.com/luaparse@0.3.1/luaparse.min.js"></script>
</head>
<body>
<div class="card">
    <h1>LUAU OBFUSCATOR <span>full rename</span></h1>
    <div class="sub">renames all locals + strings/numbers/booleans ¬∑ multi‚Äëlayer</div>

    <input type="file" id="fileInput" accept=".lua,.luau,.txt,.luc" />

    <div class="file-area" id="dropArea">
        <label for="fileInput">
            <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
                <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z" />
                <polyline points="13 2 13 9 20 9" />
            </svg>
            <div class="browse-text">click to browse</div>
            <div class="file-hint">or drag & drop .lua / .luau</div>
        </label>
    </div>

    <div id="fileName">üìÑ no file selected</div>

    <button class="action-btn" id="obfuscateBtn">üåÄ OBFUSCATE</button>

    <div id="status">‚ö° ready</div>
    <footer>output uses AST renaming + encrypted strings / numbers / booleans</footer>
</div>

<script>
(function() {
    const fileInput = document.getElementById('fileInput');
    const dropArea = document.getElementById('dropArea');
    const fileNameDiv = document.getElementById('fileName');
    const obfuscateBtn = document.getElementById('obfuscateBtn');
    const statusDiv = document.getElementById('status');

    let selectedFile = null;

    // ---------- helper functions ----------
    function randomName() {
        const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
        let name = '_';
        for (let i = 0; i < 12; i++) name += chars[Math.floor(Math.random() * chars.length)];
        return name;
    }

    function randInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    // ---------- rename all local identifiers using luaparse ----------
    function renameIdentifiers(source) {
        // parse the source into AST
        let ast;
        try {
            ast = luaparse.parse(source, { luaVersion: '5.1' });
        } catch (e) {
            throw new Error(`Parsing failed: ${e.message}`);
        }

        // We'll traverse the AST and collect all local variables, parameters, for-loop variables.
        // For each scope, we assign a random new name to each original name.
        // We need a mapping from original name to new name, scoped.

        // This is a simplified scoping: we'll use a stack of scope tables.
        // Each scope maps original name -> new random name.
        // We'll generate a new random name when we encounter a local declaration.
        // Then we replace all Identifier nodes that refer to that variable.
        // For globals, we leave unchanged.

        // We'll also need to handle function parameters, for loops, etc.
        // We'll walk the AST and collect declarations.

        const scopeStack = [{}]; // start with global scope (no local declarations)
        const renameMap = new Map(); // for identifiers we encounter, we'll store their scoped name

        // Helper to get current scope
        function currentScope() {
            return scopeStack[scopeStack.length - 1];
        }

        // Helper to push a new scope (function, for loop, etc.)
        function pushScope() {
            scopeStack.push({});
        }

        function popScope() {
            scopeStack.pop();
        }

        // Function to rename an identifier node: look up in scope stack from top to bottom
        function renameIdentifier(node) {
            if (!node || node.type !== 'Identifier') return;
            const name = node.name;
            // Don't rename Lua keywords (they are not identifiers anyway) or global objects we want to preserve.
            // We'll assume any identifier not declared as local is global and should be left alone.
            // We'll search from top scope downwards.
            for (let i = scopeStack.length - 1; i >= 0; i--) {
                const scope = scopeStack[i];
                if (scope[name] !== undefined) {
                    node.name = scope[name];
                    return;
                }
            }
            // Not found in any local scope -> it's a global; leave unchanged.
        }

        // Recursive walk function
        function walk(node) {
            if (!node || typeof node !== 'object') return;

            // Handle different node types that introduce new locals
            if (node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression') {
                // Parameters become locals in the new scope
                pushScope();
                const scope = currentScope();
                if (node.parameters) {
                    node.parameters.forEach(param => {
                        if (param.type === 'Identifier') {
                            const newName = randomName();
                            scope[param.name] = newName;
                            param.name = newName; // rename directly
                        }
                        // else might be '...' or something, ignore
                    });
                }
                // walk the body after setting parameters
                if (node.body) walk(node.body);
                popScope();
                return;
            }

            if (node.type === 'LocalStatement') {
                // Declare new local variables
                const scope = currentScope();
                node.variables.forEach((v, idx) => {
                    if (v.type === 'Identifier') {
                        const newName = randomName();
                        scope[v.name] = newName;
                        v.name = newName; // rename declaration
                    }
                });
                // walk the init if present
                if (node.init) node.init.forEach(init => walk(init));
                return;
            }

            if (node.type === 'ForGenericStatement' || node.type === 'ForNumericStatement') {
                // for loop introduces variables
                pushScope();
                const scope = currentScope();
                if (node.variables) {
                    node.variables.forEach(v => {
                        if (v.type === 'Identifier') {
                            const newName = randomName();
                            scope[v.name] = newName;
                            v.name = newName;
                        }
                    });
                }
                // walk the rest (ranges, body)
                if (node.left) walk(node.left);
                if (node.right) walk(node.right);
                if (node.step) walk(node.step);
                if (node.body) walk(node.body);
                popScope();
                return;
            }

            if (node.type === 'RepeatStatement' || node.type === 'WhileStatement' || node.type === 'IfStatement' || node.type === 'ElseifClause' || node.type === 'ElseClause') {
                // These create new scope? In Lua, they do not introduce a new lexical scope except for local declarations inside them.
                // But local declarations inside blocks will be handled by LocalStatement inside the body.
                // So we just walk children, but we don't push a scope for the block itself.
                // However, we need to handle that local variables declared inside a block are not visible outside.
                // Our scope stack will be pushed when we enter a LocalStatement? Actually LocalStatement is just a node, not a scope container.
                // So we must treat each block (list of statements) as a scope. The AST has 'body' fields that are arrays.
                // We'll need to push a new scope when we enter a block.
                // Let's modify: before walking a block (array of statements), push scope, after walking pop.
                // We'll need to identify blocks: function bodies, for bodies, if bodies, etc.
                // We'll handle this at the point we call walk on arrays? Better to check node type and if it has a 'body' that is an array, we treat as block.
                // But to keep it simple, we'll assume we already handled function and loop blocks. For if/else, we need to handle each clause as a block.
                if (node.clauses) {
                    node.clauses.forEach(clause => {
                        // clause has a 'body' array
                        if (clause.body) {
                            pushScope();
                            clause.body.forEach(stmt => walk(stmt));
                            popScope();
                        }
                    });
                } else if (node.body) {
                    // could be an array or single node
                    if (Array.isArray(node.body)) {
                        pushScope();
                        node.body.forEach(stmt => walk(stmt));
                        popScope();
                    } else {
                        walk(node.body);
                    }
                }
                // also walk condition
                if (node.condition) walk(node.condition);
                return;
            }

            // For all other nodes, recursively walk their properties
            for (let key in node) {
                if (node.hasOwnProperty(key)) {
                    const child = node[key];
                    if (Array.isArray(child)) {
                        child.forEach(item => walk(item));
                    } else {
                        walk(child);
                    }
                }
            }

            // After walking children, rename this node if it's an identifier
            if (node.type === 'Identifier') {
                renameIdentifier(node);
            }
        }

        walk(ast);

        // Now generate code back from the modified AST
        // We'll use a simple code generator that recreates Lua source.
        // luaparse provides a `ast` object, but we need to generate code.
        // There's no built-in generator in luaparse. We can use a third-party or write a simple one.
        // Instead of writing a full generator, we can use the fact that we only renamed identifiers,
        // so we can replace the original source with the new names using a string replacement technique
        // based on the mapping we have. But we have scoped mapping, so it's not trivial.
        // Alternative: use a library like "luacodegen" or "lua-ast-codegen". There is "lua-codegen" on npm, but we can't include easily.
        // Given the complexity, we'll use a simpler approach: we'll replace all identifiers in the source using the mapping,
        // but we must respect scoping to avoid renaming a global that appears as a local later.
        // Our walk already renamed the identifiers in the AST, but we need to output the modified source.
        // Since we don't have a generator, we can convert the AST back to source by traversing and building strings.
        // That's a lot of code, but we can write a basic one that handles common constructs.
        // For time, we'll attempt to use the original source and apply replacements per scope using a more sophisticated method: we'll use the AST to get the ranges of each identifier and replace them.
        // luaparse provides location information if we enable it: `locations: true` in options. Then we can get line/column and replace.
        // That might be easier: re-parse with locations, then replace the original source string by mapping each identifier node to its new name.
        // We need to know the original positions. Let's do that.

        // Re-parse with locations
        try {
            ast = luaparse.parse(source, { luaVersion: '5.1', locations: true });
        } catch (e) {
            throw new Error(`Parsing with locations failed: ${e.message}`);
        }

        // Clear previous mapping
        scopeStack.length = 0;
        scopeStack.push({});
        // We'll collect replacements: an array of { start, end, newName } (indices in source)
        const replacements = [];

        // We need a function to record a replacement for an identifier node
        function recordReplacement(node) {
            if (!node || node.type !== 'Identifier' || !node.loc) return;
            const name = node.name;
            // find the scope where it's defined
            for (let i = scopeStack.length - 1; i >= 0; i--) {
                const scope = scopeStack[i];
                if (scope[name] !== undefined) {
                    const newName = scope[name];
                    // replace from node.loc.start.index to node.loc.end.index
                    // luaparse gives line/column, not index. We need index. But we can compute from line/column if we have the source lines.
                    // This is getting very heavy. Given the time constraints, I'll opt for a simpler solution: we'll use a library that can minify Lua and rename locals.
                    // Actually, there is a library called "luamin" that does exactly this: minify Lua and rename locals. It's available on CDN.
                    // Let's switch to using luamin instead of our own parser.
                }
            }
        }

        // I'm going to change approach: use luamin (which is built on luaparse) for minification/renaming.
        // luamin is available at https://unpkg.com/luamin@1.0.3/luamin.min.js
        // We'll load it and use luamin.minify().
        // This is much simpler and reliable.

        // We'll need to add another script tag. Since we're already in an HTML file, we can dynamically load it.
        // But for simplicity, I'll add it as another script tag.
    }

    // We'll modify the obfuscate function to use luamin.
    // We need to load luamin. Let's add another script tag in the head.
    // I'll add it now dynamically to ensure it's loaded before use.

    // We'll wait for luamin to be available. We'll check if luamin is defined, otherwise load it.
    function ensureLuamin(callback) {
        if (typeof luamin !== 'undefined') {
            callback();
        } else {
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/luamin@1.0.3/luamin.min.js';
            script.onload = callback;
            document.head.appendChild(script);
        }
    }

    // ---------- string/number/boolean obfuscation ----------
    function obfuscateStringsNumbersBooleans(source) {
        // We'll use the same techniques as before, but we must be careful because luamin might have already changed some things.
        // We'll apply these transformations after luamin.

        // 1. String obfuscation
        const decodeStrName = randomName();
        const stringDecoder = `
local function ${decodeStrName}(t, k)
    local s = ""
    for i = 1, #t do
        s = s .. string.char(t[i] ~ k)
    end
    return s
end
`;

        const stringRegex = /(["'])((?:(?!\1).)*?)\1/g;
        const stringReplacements = [];
        let match;
        while ((match = stringRegex.exec(source)) !== null) {
            const full = match[0];
            const quote = match[1];
            const content = match[2];
            const key = randInt(1, 255);
            const encoded = [];
            for (let i = 0; i < content.length; i++) {
                encoded.push(content.charCodeAt(i) ^ key);
            }
            const encodedStr = '{' + encoded.join(',') + '}';
            const replacement = `${decodeStrName}(${encodedStr}, ${key})`;
            stringReplacements.push({ start: match.index, end: match.index + full.length, replacement });
        }
        for (let i = stringReplacements.length - 1; i >= 0; i--) {
            const r = stringReplacements[i];
            source = source.slice(0, r.start) + r.replacement + source.slice(r.end);
        }

        // 2. Number obfuscation
        const numberRegex = /\b(-?\d+(?:\.\d+)?)\b/g;
        const numberReplacements = [];
        while ((match = numberRegex.exec(source)) !== null) {
            const full = match[0];
            const num = parseFloat(full);
            // generate a random expression that yields the same number
            const a = Math.random() * 1000;
            const b = Math.random() * 1000;
            const c = a + b - num;
            const expr = `((${a.toFixed(6)} + ${b.toFixed(6)}) - ${c.toFixed(6)})`;
            numberReplacements.push({ start: match.index, end: match.index + full.length, replacement: expr });
        }
        for (let i = numberReplacements.length - 1; i >= 0; i--) {
            const r = numberReplacements[i];
            source = source.slice(0, r.start) + r.replacement + source.slice(r.end);
        }

        // 3. Boolean obfuscation
        source = source.replace(/\btrue\b/g, '(1==1)');
        source = source.replace(/\bfalse\b/g, '(1==0)');

        // 4. Junk code insertion
        const junkLines = [];
        for (let i = 0; i < 3; i++) {
            junkLines.push(`local ${randomName()} = ${randInt(1,1000)}`);
        }
        junkLines.push(`local function ${randomName()}() return "${randomName()}" end`);
        const junkBlock = junkLines.join('; ') + '; ';

        return stringDecoder + junkBlock + '\n' + source;
    }

    // ---------- main obfuscation pipeline ----------
    function obfuscateFull(source) {
        // Remove BOM if present
        if (source.charCodeAt(0) === 0xFEFF) source = source.slice(1);

        // Step 1: Minify and rename locals using luamin
        let minified;
        try {
            minified = luamin.minify(source);
        } catch (e) {
            throw new Error(`luamin failed: ${e.message}`);
        }

        // Step 2: Apply string/number/boolean obfuscation
        const final = obfuscateStringsNumbersBooleans(minified);

        return final;
    }

    // ---------- UI ----------
    function updateFileInfo(file) {
        if (file) fileNameDiv.innerHTML = `üìÑ ${file.name}  (${(file.size / 1024).toFixed(1)} KB)`;
        else fileNameDiv.innerHTML = 'üìÑ no file selected';
    }

    function handleFile(file) {
        if (!file) return;
        selectedFile = file;
        updateFileInfo(file);
        statusDiv.innerHTML = '‚úÖ file loaded, ready to obfuscate';
    }

    fileInput.addEventListener('change', (e) => handleFile(e.target.files[0]));

    dropArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropArea.style.borderColor = '#b3a0ff';
        dropArea.style.background = '#242033';
    });

    dropArea.addEventListener('dragleave', (e) => {
        e.preventDefault();
        dropArea.style.borderColor = '#3b344e';
        dropArea.style.background = '#13111c';
    });

    dropArea.addEventListener('drop', (e) => {
        e.preventDefault();
        dropArea.style.borderColor = '#3b344e';
        dropArea.style.background = '#13111c';
        const file = e.dataTransfer.files[0];
        if (file) {
            fileInput.files = e.dataTransfer.files;
            handleFile(file);
        }
    });

    dropArea.addEventListener('click', () => fileInput.click());

    obfuscateBtn.addEventListener('click', () => {
        if (!selectedFile) {
            statusDiv.innerHTML = '‚ö†Ô∏è select a file first';
            return;
        }

        statusDiv.innerHTML = '‚è≥ loading luamin & obfuscating ...';
        obfuscateBtn.disabled = true;

        ensureLuamin(() => {
            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    const source = ev.target.result;
                    if (!source.trim()) {
                        statusDiv.innerHTML = '‚ö†Ô∏è file is empty';
                        return;
                    }

                    const obfuscated = obfuscateFull(source);

                    let baseName = selectedFile.name;
                    const lastDot = baseName.lastIndexOf('.');
                    if (lastDot !== -1) baseName = baseName.substring(0, lastDot);
                    const outputName = baseName + '_obfuscated.lua';

                    const blob = new Blob([obfuscated], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = outputName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    statusDiv.innerHTML = 'üéâ obfuscation complete ‚Äì download started';
                } catch (err) {
                    console.error(err);
                    statusDiv.innerHTML = '‚ùå error: ' + err.message;
                } finally {
                    obfuscateBtn.disabled = false;
                }
            };

            reader.onerror = () => {
                statusDiv.innerHTML = '‚ùå failed to read file';
                obfuscateBtn.disabled = false;
            };

            reader.readAsText(selectedFile);
        });
    });

    updateFileInfo(null);
})();
</script>
</body>
</html>
